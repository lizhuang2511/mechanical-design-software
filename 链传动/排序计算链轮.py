# -*- coding = utf-8 -*-
# @time:2023/11/29 3:58
# Author:lizhuang
# @File:排序计算链轮.py
# @Software:PyCharm
class test():
    def __init__(self):
        print('Python')
if __name__ == '__main__': 
  test=test()
  '''A4 = Axis
  distance
  B1 = MC_X
  B3 = ul
  B4 = Number
  of
  links
  S_HRI00 = FALSE
  S_HRA00 = 0
  S_HRA01 = 1
  S_HRA02 = 1
  S_HRA03 = 1
  _ChLinksFlag = 1
  S_HRB00 = 0
  S_HRA04 = 1
  _K1_Flag = 0
  _K2_Flag = 1
  _K3_Flag = TRUE
  _K4_Flag = 1
  _K5_Flag = 1
  _K6_Flag = 1
  _K7_Flag = FALSE
  S_HRA05 = 1
  C1 = MC_Chain_d1
  D1 = MC_Chain_d3
  E1 = MC_Chain_b1
  F1 = MC_Chain_b2
  XM_ErrMsg1 = 计算无误
  G1 = MC_Pitch
  XM_ErrMsg2 = 检查路径:
  _UnitPT_BCKP = 1
  _TeethOdd_1 = 1
  H1 = MC_Chain_g
  S_FlagProjectAuthorName = TRUE
  S_FlagProjectDate = TRUE
  S_FlagProjectNumber = TRUE
  S_FlagProjectName = TRUE
  S_FlagProjectInfo = TRUE
  S_FlagProjectNotes = TRUE
  H116 = 2
  _UnitPT = 1
  H122 = 2
  _LoadTypeA = 2
  _LoadTypeB = 2
  _Lubrication = 1
  _LinksEven = 1
  _TeethOdd_2 = 1
  H130 = 1
  _ChPt = 1
  _AxisDistanceFlag = 1
  H134 = 8
  _Sort_Pt = 8
  H137 = 1
  _SolutionPt = 3
  H139 = 2
  _NoPt = 19
  H180 = 1
  _StandardPt = 1
  M118 = P
  M119 = n
  M120 = n
  M121 = i
  M122 = Mk
  M142 = t
  M143 = z
  M144 = Dp
  M145 = C
  M146 = C
  M147 = X
  M148 = L
  M149 = v
  M150 = Pp
  M151 = Fu / Fc
  M152 = FB / Fr
  M153 = SB
  M154 = SD
  M155 = p
  M156 = SP
  M157 = m
  M174 = K1
  M175 = K2
  M176 = K3
  M177 = K4
  M178 = K5
  M179 = K6
  M180 = K7
  M184 = y
  M186 = x
  M201 = Da
  M202 = Dp
  M203 = Df
  M204 = R1
  M205 = R2
  M206 = a
  M208 = bf
  M209 = ba
  M210 = rx
  M211 = f
  M212 = Dg
  N1 = MC_R1
  XM_0002 = 链轮1
  _P1 = 40
  _n1 = 970
  _C_Auto_req = 27.5590551181102
  _z1min = 17
  _z1 = 21
  _C_req = 40.18
  _ChLinks = 118
  _K1 = 1
  _K2 = 1.04761910438537
  _K4 = 0.999113976955413
  _K5 = 1
  _K6 = 1
  _K7 = 1
  N189 = d1
  N190 = d3
  N191 = b1
  N192 = b2
  N193 = t
  N194 = g
  N195 = l
  N196 = e
  N197 = s1
  N198 = s2
  O1 = MC_bf
  P1 = MC_ba
  XM_0003 = 链轮2
  XM_PrjNo = 项目编号
  S_ProjectNumber = 111 - 111
  _n2_req = 390
  P123 = v5
  _z1max = 21
  _SolutionStatus = None
  P156 = > 1.00
  _K7_prop = 1
  Q1 = MC_rx
  R1 = MC_f
  S1 = MC_z1
  S3 = ul
  S119 = [ / min]
  S120 = [ / min]
  S_ProjectID = CHAINS_01
  XM_0100 = 链:
  S_ExtraCopy_FlagIN = 1
  _ScreenFlag = 2
  W131 = 5
  W132 = 0.75
  W133 = 3
  W134 = 7
  W135 = 5
  W136 = 0.9
  _ChainTypeAuto = 1
  _Density = 7800
  _Temperature = -39.9945102994004
  _Life = 15000
  X1 = MC_alfa1
  X3 = deg
  Y1 = MC_Dg1
  Z1 = MC_z2
  Z3 = ul
  AA1 = MC_Da2
  AB1 = MC_D2
  AC1 = MC_Df2
  AD1 = MC_R2_2
  ABS = '返回数的绝对值'
  ACCRINT = '返回定期付息有价证券的应计利息'
  ACCRINTM = '返回到期一次性付息有价证券的应计利息'
  ACOS = '返回数的反余弦'
  ACOSH = '返回数的反双曲余弦值'
  ADDRESS = '以文本形式返回对工作表中单个单元格的引用'
  AMORDEGRC = '返回每个会计期间的折旧值'
  AMORLINC = '返回每个会计期间的折旧值'
  AND = '如果所有参数为TRUE，则返回TRUE'
  AREAS = '返回引用中的区域数'
  ASC = '将字符串中的全角（双字节）英文字母或片假名更改为半角（单字节）字符。'
  ASIN = '返回数的反正弦'
  ASINH = '返回数的反双曲正弦值'
  ATAN = '返回数的反正切'
  ATAN2 = '从X和Y坐标返回反正切'
  ATANH = '返回参数的反双曲正切值'
  AVEDEV = '返回一组数据与其均值的绝对偏差的平均值'
  AVERAGE = '返回参数的平均值'
  AVERAGEA = '返回参数的平均值，包括数字、文本和逻辑值'
  BESSELI = '返回经过修改的贝塞尔函数In(x)'
  BESSELJ = '返回贝塞尔函数Jn(x)'
  BESSELK = '返回经过修改的贝塞尔函数Kn(x)'
  BESSELY = '返回贝塞尔函数Yn(x)'
  BETADIST = '返回Beta分布累积函数的函数值'
  BETAINV = '返回Beta分布累积函数的反函数值'
  BIN2HEX = '将二进制数转换为十六进制数'
  BIN2OCT = '将二进制数转换为八进制数'
  BINOMDIST = '返回单独项二项式分布概率'
  CALL = '调用动态链接库(DLL)或代码源中的过程'
  CEILING = '对数字取整为最接近的整数或最接近的多个有效数字'
  CELL = '返回有关单元格格式、位置或内容的信息'
  CHAR = '返回由编码号码所指定的字符'
  CHIDIST = '返回chi平方分布的单尾概率'
  CHIINV = '返回chi平方分布的反单尾概率'
  CHITEST = '返回独立性检验值'
  CHOOSE = '从值的列表中选择一个值'
  CLEAN = '删除文本中的所有不可打印字符'
  CODE = '返回文本串中第一个字符的数字编码'
  COLUMN = '返回引用的列号'
  COLUMNS = '返回引用中的列数'
  COMBIN = '返回给定数目对象的组合数'
  COMPLEX = '将实系数和虚系数转换为复数'
  CONCATENATE = '将多个文本项连接到一个文本项中'
  CONFIDENCE = '返回总体平均值的置信区间'
  CONVERT = '将一种度量单位制中的数字转换为另一种度量单位制'
  CORREL = '返回两个数据集之间的相关系数'
  COS = '返回数的余弦'
  COSH = '返回数的双曲线余弦'
  COUNT = '计算参数列表中的数字多少'
  COUNTA = '计算参数列表中的值多少'
  COUNTBLANK = '计算区域中空单元格的个数'
  COUNTIF = '计算符合给定条件的区域中的非空单元格数'
  COUPDAYBS = '返回当前付息期内截止到成交日的天数'
  COUPDAYS = '返回成交日所在的付息期的天数'
  COUPDAYSNC = '返回从成交日到下一付息日之间的天数'
  COUPNCD = '返回成交日过后的下一付息日的日期'
  COUPNUM = '返回成交日和到期日之间的利息应付次数'
  COUPPCD = '返回成交日之前的上一付息日的日期'
  COVAR = '返回协方差，即成对偏移乘积的平均数'
  CRITBINOM = '返回使累积二项式分布小于等于临界值的最小值'
  CUMIPMT = '返回两个期间之间累计偿还的利息数额'
  CUMPRINC = '返回两个期间之间累计偿还的本金数额'
  DATE = '返回特定时间的系列数'
  DATEDIF = '计算两个日期之间的年、月、日数'
  DATEVALUE = '将文本格式的日期转换为系列数'
  DAVERAGE = '返回选定数据库项的平均值'
  DAY = '将系列数转换为月份中的日'
  DAYS360 = '按每年360天计算两个日期之间的天数'
  DB = '使用固定余额递减法，返回一笔资产在指定期间内的折旧值'
  DCOUNT = '计算数据库中包含数字的单元格的个数'
  DCOUNTA = '计算数据库中非空单元格的个数'
  DDB = '使用双倍余额递减法或其他指定方法，返回一笔资产在指定期间内的折旧值'
  DDE = '和外部函数'
  DEC2BIN = '将十进制数转换为二进制数'
  DEC2HEX = '将十进制数转换为十六进制数'
  DEC2OCT = '将十进制数转换为八进制数'
  DEGREES = '将弧度转换为度'
  DELTA = '检测两个值是否相等'
  DEVSQ = '返回偏差的平方和'
  DGET = '从数据库中提取满足指定条件的单个记录'
  DISC = '返回有价证券的贴现率'
  DMAX = '返回选定数据库项中的最大值'
  DMIN = '返回选定数据库项中的最小值'
  DOLLAR = '使用当前格式将数字转换为文本'
  DOLLARDE = '将按分数表示的价格转换为按小数表示的价格'
  DOLLARFR = '将按小数表示的价格转换为按分数表示的价格'
  DPRODUCT = '乘以特定字段（此字段中的记录为数据库中满足指定条件的记录）中的值'
  DSTDEV = '根据数据库中选定项的示例估算标准偏差'
  DSTDEVP = '根据数据库中选定项的样本总体计算标准偏差'
  DSUM = '对数据库中满足条件的记录的字段列中的数字求和'
  DURATION = '返回定期付息有价证券的修正期限'
  DVAR = '根据数据库中选定项的示例估算方差'
  DVARP = '根据数据库中选定项的样本总体计算方差'
  EDATE = '返回在开始日期之前或之后指定月数的某个日期的系列数'
  EFFECT = '返回实际年利率'
  EOMONTH = '返回指定月份数之前或之后某月的最后一天的系列数'
  ERF = '返回误差函数'
  ERFC = '返回余误差函数'
  ERROR.TYPE = '返回对应于错误类型的数字'
  EVEN = '将数向上取整至最接近的偶数整数'
  EXACT = '检查两个文本值是否相同'
  EXP = '返回e的指定数乘幂'
  EXPONDIST = '返回指数分布'
  FACT = '返回数的阶乘'
  FACTDOUBLE = '返回参数Number的半阶乘'
  FDIST = '返回F概率分布'
  FIND = '在其他文本值中查找文本值（区分大小写）'
  FINV = '返回反F概率分布'
  FISHER = '返回Fisher变换'
  FISHERINV = '返回反Fisher变换'
  FIXED = '使用固定的十进制数将数字设置为文本格式'
  FLOOR = '将参数Number沿绝对值减小的方向取整'
  FORECAST = '根据给定的数据计算或预测未来值'
  FREQUENCY = '返回作为矢量数组的频率分布'
  FTEST = '返回F检验的结果'
  FV = '返回投资的未来值'
  FVSCHEDULE = '基于一系列复利返回本金的未来值'
  GAMMADIST = '返回伽玛分布'
  GAMMAINV = '返回反伽玛累积分布'
  GAMMALN = '返回伽玛函数的自然对数，Γ(x)'
  GCD = '返回最大公约数'
  GEOMEAN = '返回几何平均数'
  GESTEP = '检测数字是否大于某个阈值'
  GETPIVOTDATA = '返回存储在数据透视表中的数据'
  GROWTH = '根据给定的数据预测指数增长值'
  HARMEAN = '返回数据集合的调和平均值'
  HEX2BIN = '将十六进制数转换为二进制数'
  HEX2DEC = '将十六进制数转换为十进制数'
  HEX2OCT = '将十六进制数转换为八进制数'
  HLOOKUP = '查找数组的顶行并返回指示单元格的值'
  HOUR = '将系列数转换为小时'
  HYPERLINK = '创建快捷方式或跳转，打开存储在网络服务器、企业内部网或Internet上的文档'
  HYPGEOMDIST = '返回超几何分布'
  IF = '指定要执行的逻辑检测'
  IMABS = '返回复数的绝对值（模）'
  IMAGINARY = '返回复数的虚系数'
  IMARGUMENT = '返回参数theta，一个以弧度表示的角'
  IMCONJUGATE = '返回复数的共轭复数'
  IMCOS = '返回复数的余弦'
  IMDIV = '返回两个复数的商'
  IMEXP = '返回复数的指数'
  IMLN = '返回复数的自然对数'
  IMLOG10 = '返回复数的常用对数'
  IMLOG2 = '返回复数的以2为底数的对数'
  IMPOWER = '返回复数的整数幂'
  IMPRODUCT = '返回两个复数的乘积'
  IMREAL = '返回复数的实系数'
  IMSIN = '返回复数的正弦'
  IMSQRT = '返回复数的平方根'
  IMSUB = '返回两个复数的差'
  IMSUM = '返回两个复数的和'
  INDEX = '使用索引从引用或数组中选择值'
  INDIRECT = '返回由文本值表示的引用'
  INFO = '返回有关当前操作环境的信息'
  INT = '将数向下取整至最接近的整数'
  INTERCEPT = '返回回归线截距'
  INTRATE = '返回一次性付息证券的利率'
  IPMT = '返回给定期间内投资的利息偿还额'
  IRR = '返回一组现金流的内部收益率'
  ISBLANK = '如果值为空，则返回TRUE。'
  ISERR = '1'
  ISERROR = '如果值为任何错误值，则返回TRUE。'
  ISEVEN = '如果数为偶数，则返回TRUE。'
  ISLOGICAL = '如果值为逻辑值，则返回TRUE。'
  ISNA = '1'
  ISNONTEXT = '如果值不是文本，则返回TRUE。'
  ISNUMBER = '如果值为数字，则返回TRUE。'
  ISODD = '如果数字为奇数，则返回TRUE。'
  ISPMT = '计算在投资的特定期间内支付的利息'
  ISREF = '如果值为引用，则返回TRUE。'
  ISTEXT = '如果值为文本，则返回TRUE。'
  JIS = '将字符串中的半角（单字节）英文字符或片假名更改为全角（双字节）字符。'
  KURT = '返回数据集的峰值'
  LARGE = '返回数据集中第k个最大值'
  LCM = '返回最小公倍数'
  LEFT = '返回文本值中最左边的字符'
  LEN = '返回文本串中字符的个数'
  LINEST = '返回线条趋势的参数'
  LN = '返回数的自然对数'
  LOG = '返回数的指定底数的对数'
  LOG10 = '返回以10为底的对数'
  LOGEST = '返回指数趋势的参数'
  LOGINV = '返回反对数正态分布'
  LOGNORMDIST = '返回对数正态分布的累积函数'
  LOOKUP = '在向量或数组中查找值'
  LOWER = '将文本转换为小写'
  MATCH = '在引用或数组中查找值'
  MAX = '返回参数列表中的最大值'
  MAXA = '返回参数列表中的最大值，包括数字、文本和逻辑值'
  MDETERM = '返回数组的矩阵行列式'
  MDURATION = '返回假设面值100的有价证券的Macauley修正期限'
  MEDIAN = '返回给定数字的中位数'
  MID = '从文本串中的指定位置开始返回特定数目的字符'
  MIN = '返回参数列表的最小值'
  MINA = '返回参数列表中的最小值，包括数字、文本和逻辑值'
  MINUTE = '将系列数转换为分钟'
  MINVERSE = '返回数组的反矩阵'
  MIRR = '返回正负现金流使用不同利率的修正内部收益率'
  MMULT = '返回两个数组的矩阵乘积'
  MOD = '返回两数相除的余数'
  MODE = '返回数据集中的出现最多的值'
  MONTH = '将系列数转换为月'
  MROUND = '返回参数按指定基数取整后的数值'
  MULTINOMIAL = '返回一组数的多项式'
  N = '返回转换为数字的值'
  NA = '2'
  NEGBINOMDIST = '返回负二项式分布'
  NETWORKDAYS = '返回两个日期之间的完整工作日数'
  NOMINAL = '返回名义年利率'
  NORMDIST = '返回普通累积分布'
  NORMINV = '返回反普通累积分布'
  NORMSDIST = '返回标准普通累积分布'
  NORMSINV = '返回反标准普通累积分布'
  NOT = '反转参数的逻辑值'
  NOW = '返回当前日期和时间的系列数'
  NPER = '返回投资的期数'
  NPV = '基于一系列现金流和固定的各期贴现率，返回一项投资的净现值'
  OCT2BIN = '将八进制数转换为二进制数'
  OCT2DEC = '将八进制数转换为十进制数'
  OCT2HEX = '将八进制数转换为十六进制数'
  ODD = '将数取整至最接近的奇数整数'
  ODDFPRICE = '返回首期付息日不固定的面值100的有价证券的价格'
  ODDFYIELD = '返回首期付息日不固定的有价证券的收益率'
  ODDLPRICE = '返回末期付息日不固定的面值100的有价证券的价格'
  ODDLYIELD = '返回末期付息日不固定的有价证券的收益率'
  OFFSET = '从给定引用中返回引用偏移量'
  OR = '如果任何参数为TRUE，则返回TRUE'
  PEARSON = '返回Pearson乘积矩相关系数'
  PERCENTILE = '返回区域中值的第k个百分比'
  PERCENTRANK = '返回数据集中值的百分比排位'
  PERMUT = '返回对象给定数的排列数'
  PHONETIC = '从文本串中提取拼音(furigana)字符'
  PI = '返回Pi值'
  PMT = '返回投资或贷款的每期付款额'
  POISSON = '返回泊松分布'
  POWER = '返回数的乘幂结果'
  PPMT = '返回投资在某一给定期次内的本金偿还额'
  PRICE = '返回定期付息的面值100的有价证券的价格'
  PRICEDISC = '返回折价发行的面值100的有价证券的价格'
  PRICEMAT = '返回到期付息的面值100的有价证券的价格'
  PROB = '返回区域中的值在两个限制之间的概率'
  PRODUCT = '将所有以参数形式给出的数字相乘'
  PROPER = '将文本值中每个单词的首字母设置为大写'
  PV = '返回投资的现值'
  QUARTILE = '返回数据集的四分位数'
  QUOTIENT = '返回商的整数部分'
  RADIANS = '将度转换为弧度'
  RAND = '返回0和1之间的随机数'
  RANDBETWEEN = '返回指定数之间的随机数'
  RANK = '返回某数在数字列表中的排位'
  RATE = '返回年金的各期利率'
  RECEIVED = '返回一次性付息的有价证券到期收回的金额'
  REGISTER.ID = '返回已注册的指定DLL或代码源的注册ID'
  REPLACE = '替换文本中的字符'
  REPT = '按给定次数重复文本'
  RIGHT = '返回文本值中最右边的字符'
  ROMAN = '将阿拉伯数字转换为文本形式的罗马数字'
  ROUND = '将数取整至指定数'
  ROUNDDOWN = '将数向下*近0值取整'
  ROUNDUP = '将数向上远离0值取整'
  ROW = '返回引用的行号'
  ROWS = '返回引用中的行数'
  RSQ = '返回Pearson乘积力矩相关系数的平方'
  SEARCH = '在其他文本值中查找文本值（不区分大小写）'
  SECOND = '将系列数转换为秒'
  SERIESSUM = '返回基于公式的幂级数的和'
  SIGN = '返回数的正负号'
  SIN = '返回给定角度的正弦'
  SINH = '返回数的双曲正弦值'
  SKEW = '返回分布的偏斜度'
  SLN = '返回一项资产每期的直线折旧费'
  SLOPE = '返回线性回归直线的斜率'
  SMALL = '返回数据集中的第k个最小值'
  SQL.REQUEST = '连接外部数据源，并从工作表中运行查询，然后将结果作为数组返回，而无需进行宏编程。'
  SQRT = '返回正平方根'
  SQRTPI = '返回某数与Pi的乘积的平方根'
  STANDARDIZE = '返回正态化数值'
  STDEV = '估计样本的标准偏差'
  STDEVA = '估计样本的标准偏差，包括数字、文本和逻辑值'
  STDEVP = '计算整个样本总体的标准偏差'
  STDEVPA = '计算整个样本总体的标准偏差，包括数字、文本和逻辑值'
  STEYX = '返回通过线性回归法计算y预测值时所产生的标准误差'
  SUBSTITUTE = '在文本串中使用新文本替换旧文本'
  SUBTOTAL = '返回清单或数据库中的分类汇总'
  SUM = '添加参数'
  SUMIF = '按给定条件添加指定单元格'
  SUMPRODUCT = '返回相对应的数组部分的乘积和'
  SUMSQ = '返回参数的平方和'
  SUMX2MY2 = '返回两个数组中相对应值的平方差之和'
  SUMX2PY2 = '返回两个数组中相对应值的平方和之和'
  SUMXMY2 = '返回两个数组中相对应值差的平方之和'
  SYD = '返回某项资产按年限总和折旧法计算的某期的折旧值'
  T = '将参数转换为文本'
  TAN = '返回数的正切'
  TANH = '返回数的双曲正切值'
  TBILLEQ = '返返回国库券的债券等效收益率'
  TBILLPRICE = '返回面值100的国库券的价格'
  TBILLYIELD = '返回国库券的收益率'
  TDIST = '返回学生氏-t分布'
  TEXT = '设置数字的格式并将其转换为文本'
  TIME = '返回特定时间的系列数'
  TIMEVALUE = '将文本格式的时间转换为系列数'
  TINV = '返回反学生氏-t分布'
  TODAY = '返回当天日期的系列数'
  TRANSPOSE = '返回数组的转置'
  TREND = '返回沿线性趋势的值'
  TRIM = '删除文本中的空格'
  TRIMMEAN = '返回数据集的内部平均值'
  TRUNC = '将数截尾为整数'
  TTEST = '返回与学生氏-t检验相关的概率'
  UPPER = '将文本转换为大写'
  VALUE = '将文本参数转换为数字'
  VAR = '估计样本的方差'
  VARA = '估计样本的方差，包括数字、文本和逻辑值'
  VARP = '计算整个样本总体的方差'
  VARPA = '计算整个样本总体的方差，包括数字、文本和逻辑值'
  VDB = '使用递减余额法，返回指定期间内或某一时间段内的资产折旧额'
  VLOOKUP = '查找数组的第一列并移过行，然后返回单元格的值'
  WEEKDAY = '将系列数转换为星期'
  WEIBULL = '返回韦伯分布'
  WORKDAY = '返回指定工作日数之前或之后某日期的系列数'
  XIRR = '返回一组不定期发生的现金流的内部收益率'
  xlfctBIN2DEC = 'BIN2DEC将二进制数转换为十进制数'
  xlfctTYPE = 'TYPE返回表示值的数据类型的数字'
  XNPV = '返回一组不定期发生的现金流的净现值'
  YEAR = '将系列数转换为年'
  YEARFRAC = '返回代表start_date（开始日期）和end_date（结束日期）之间天数的以年为单位的分数'
  YEN = '使用￥(yen)货币符号将数字转换为文本。'
  YIELD = '返回定期付息有价证券的收益率'
  YIELDDISC = '返回折价发行的有价证券的年收益率，例如：国库券'
  YIELDMAT = '返回到期付息的有价证券的年收益率'
  ZTEST = '返回z检验的双尾P值'
  X143 = 变量值
  X137 = 变量值
  W208 = 变量值
  W176 = 变量值
  TblAprox = 变量值
  RowsHideRange = 变量值
  _R1 = 变量值
  _RA = 变量值
  Y206 = 变量值
  Y205 = 变量值
  W206 = 变量值
  W205 = 变量值
  W204 = 变量值
  W202 = 变量值
  W201 = 变量值
  S_Units = 变量值
  PulleyMass = 变量值
  _Pitch_mm = 变量值
  XC_0024 = 变量值
  XC_0008 = 变量值
  H109 = 变量值
  H108 = 变量值
  H107 = 变量值
  H106 = 变量值
  H105 = 变量值
  H104 = 变量值
  B180 = 变量值
  B179 = 变量值
  B178 = 变量值
  B177 = 变量值
  B176 = 变量值
  B175 = 变量值
  B174 = 变量值
  B147 = 变量值
  _LubrRecPt = 变量值
  _v = 变量值
  _v_m = 变量值
  Z143 = 变量值
  _Sigma = 变量值
  _sigma_tbl = 变量值
  _Safety_S = 变量值
  _Safety_P = 变量值
  _Safety_D = 变量值
  _Pp = 变量值
  _PiMPa = 变量值
  _Fr = 变量值
  _AxisDist_Min = 变量值
  H117 = 变量值
  CellTransmitVal = 变量值
  CAprox = 变量值
  _Pitch_i = 变量值
  _xR2_2 = 变量值
  _xR1_1 = 变量值
  _xdf2 = 变量值
  _xda2 = 变量值
  _xalfa1 = 变量值
  _v_max = 变量值
  _PiMPa_cor = 变量值
  _K3 = 变量值
  _Fu = 变量值
  _Err0 = 变量值
  _Dg1 = 变量值
  N211 = 变量值
  _bf = 变量值
  W168 = 变量值
  _v_var_max = 变量值
  S_XProjectInfo = XM_0100 & INDEX(T_ChainType, _ChPt, 4) & ":  " & _Chain_No & ";  n1=" & _n1 & ";  n2=" & ROUND(_n2,
                                                                                                                  0) & ";  z1=" & _z1 & ";  z2=" & _z2 & ";  P=" & ROUND(
      _P1, 2) & IF(S_Units, "[kW]", "[HP]")
  Y137 = X137
  _K3 = W176
  _SolutionValidX = SUM(Y131:Y137)
  _IsValid = SUM(X140:AC140)
  _SolutionValid = SUM(X131:X137)
  W166 = ROUND((1.2 * 10000000 * IF(S_Units, _P1, _P1 * 0.7457) / _n1) ^ 0.333, 1) / 1000
  _PpTable = MIN(INDEX(T_ChainType, _ChPt, 7), INDEX(T_ChainType, _ChPt, 9)) * _MultipleStrand / IF(S_Units, 1, 0.7457)
  AA143 = INT(9 + 0.2 * _Pitch_mm)
  _SortDirection = INDEX(T_Sort, _Sort_Pt, 3)
  _SortColumn = INDEX(T_Sort, _Sort_Pt, 2)
  _Solz1 = INDEX(T_Solutions, _SolutionPt, 3)
  _SolAxisDist = INDEX(T_Solutions, _SolutionPt, 11)
  _SolChainID = INDEX(T_Solutions, _SolutionPt, 1)
  _Y = INDEX(T_ServiceFactors, _LoadTypeB, _LoadTypeA)
  N183 = INDEX(T_LubricationR, _LubrRecPt, 2)
  N182 = INDEX(T_LubricationR, _LubrRecPt, 1)
  _K9 = INDEX(T_ChainType, _ChPt, 20)
  _ChainTblName = INDEX(T_ChainType, _ChPt, 2)
  X155 = INDEX(T_ChainType, _ChPt, 19)
  _Efficiency = INDEX(T_ChainType, _ChPt, 18)
  _Standard = INDEX(T_ChainType,$H$131, 4)
  _BArrea = INDEX(INDIRECT(_ChainTblName), _NoPt, 9) / IF(S_Units, 1, (25.4 ^ 2))
  _Massm = INDEX(INDIRECT(_ChainTblName), _NoPt, 8)
  _FB = INDEX(INDIRECT(_ChainTblName), _NoPt, 7) * IF(S_Units, 1, 0.22481) * _OddChLinksCoeff
  _rows = INDEX(INDIRECT(_ChainTblName), _NoPt, 6)
  _Pitch = INDEX(INDIRECT(_ChainTblName), _NoPt, 5) * IF(S_Units, 1, 1 / 25.4)
  _Chain_ex = INDEX(INDIRECT(_ChainTblName), _NoPt, 25) * IF(S_Units, 1, 1 / 25.4)
  _Chain_e = INDEX(INDIRECT(_ChainTblName), _NoPt, 24) * IF(S_Units, 1, 1 / 25.4)
  _Chain_s2 = INDEX(INDIRECT(_ChainTblName), _NoPt, 23) * IF(S_Units, 1, 1 / 25.4)
  _Chain_s1 = INDEX(INDIRECT(_ChainTblName), _NoPt, 22) * IF(S_Units, 1, 1 / 25.4)
  _Chain_g = INDEX(INDIRECT(_ChainTblName), _NoPt, 21) * IF(S_Units, 1, 1 / 25.4)
  W165 = INDEX(INDIRECT(_ChainTblName), _NoPt, 20) * 0.001
  _Chain_No = INDEX(INDIRECT(_ChainTblName), _NoPt, 2)
  _Chain_L = INDEX(INDIRECT(_ChainTblName), _NoPt, 19) * IF(S_Units, 1, 1 / 25.4)
  _Chain_d3 = INDEX(INDIRECT(_ChainTblName), _NoPt, 18) * IF(S_Units, 1, 1 / 25.4)
  _Chain_d3_mm = INDEX(INDIRECT(_ChainTblName), _NoPt, 18)
  _Chain_d1 = INDEX(INDIRECT(_ChainTblName), _NoPt, 17) * IF(S_Units, 1, 1 / 25.4)
  _Chain_d1_mm = INDEX(INDIRECT(_ChainTblName), _NoPt, 17)
  _Chain_b2 = INDEX(INDIRECT(_ChainTblName), _NoPt, 16) * IF(S_Units, 1, 1 / 25.4)
  _Chain_b1 = INDEX(INDIRECT(_ChainTblName), _NoPt, 15) * IF(S_Units, 1, 1 / 25.4)
  _Sigma = IF(S_Units, ROUND(_Fr / _BArrea, 2), ROUND(_Fr / _BArrea, 0))
  _RA = IF(S_Units, 2, 3)
  _v_m = IF(S_Units, _v, _v / 196.8503937)
  _TemperatureC = IF(S_Units, _Temperature, 5 / 9 * (_Temperature - 32))
  _Pitch_i = IF(S_Units, _Pitch / 25.4, _Pitch)
  N122 = IF(S_Units, _P1 * 9550 / _n1, _P1 * 63000 / _n1)
  _Fu = IF(S_Units, _P1 * 1000 / _v, _P1 * 33000 / _v)
  _Fc = IF(S_Units, _Massm * _v ^ 2, _Massm * 0.6723 * (_v ^ 2) / 115900)
  _Fu_lbf = IF(S_Units, _Fu * 0.22481, _Fu)
  W143 = IF(INT(_z1 / 2) <> _z1 / 2, 0, IF(_TeethOdd_1=1, 1, 0))
  _OddChLinksCoeff = IF(INT(_ChLinks / 2) <> _ChLinks / 2, INDEX(T_ChainType, _ChPt, 22), 1)
  C109 = IF(H109, 1, 0)
  C108 = IF(H108, 1, 0)
  C107 = IF(H107, 1, 0)
  C106 = IF(H106, 1, 0)
  C105 = IF(H105, 1, 0)
  C104 = IF(H104, 1, 0)
  C180 = IF(B180, 1, 0)
  C179 = IF(B179, 1, 0)
  C178 = IF(B178, 1, 0)
  C177 = IF(B177, 1, 0)
  C176 = IF(B176, 1, 0)
  C175 = IF(B175, 1, 0)
  C174 = IF(B174, 1, 0)
  C147 = IF(B147, 1, 0)
  W184 = IF(AND(_Lubrication > 2, _LubrRecPt > 2), 1, 0)
  Y133 = IF(_v < _v_max, 0, 1)
  X136 = IF(_sigma_tbl / _Sigma > W136, 0, 1)
  Y136 = IF(_sigma_tbl / _Sigma > 1, 0, 1)
  X135 = IF(_Safety_S < W135, 1, 0)
  X134 = IF(_Safety_S < W134, 1, 0)
  AC140 = IF(_Safety_P > 1, 1, 0)
  X133 = IF(_PpTable / _Pp > W133, 1, 0)
  X132 = IF(_PpTable / _Pp < W132, 1, 0)
  Y132 = IF(_PpTable / _Pp < 1, 1, 0)
  Y140 = IF(_Pp < _PpTable, 1, 0)
  X131 = IF(_PiMPa < W131, 1, 0)
  AB140 = IF(_Fr / _BArrea < _sigma_tbl, 1, 0)
  X137 = IF(_C_req < _AxisDist_Min, 1, 0)
  S_Units = H117 - 1
  A176 = CellTransmitVal(W176 & _K3)
  _MultipleStrand = CAprox(INDEX(T_ChainType, _ChPt, 17), _rows)
  _C_optimal = 40 * _Pitch
  S_ExtraCopy_FlagOUT = 2 * S_ExtraCopy_FlagIN
  _alfa1_max = 140 - 90 / _z1
  _alfa1_min = 120 - 90 / _z1
  W155 = 1000 * (82.5 / ((7.95 ^ _Pitch_i) * (1.0278 ^ _z1) * (1.323 ^ (_Fu_lbf * 0.001)))) ^ (
              1 / (1.59 * LOG10(_Pitch_i) + 1.873))
  W180 = 1 / (15000 / _Life) ^ 0.4
  _rx = 1.5 * _Chain_d1
  _f = 0.7 * _Pitch
  _R1max = 0.505 * _Chain_d3 + 0.069 * _Chain_d3_mm ^ 0.33 * IF(S_Units, 1, 1 / 25.4)
  _R1min = 0.505 * _Chain_d3_mm * IF(S_Units, 1, 1 / 25.4)
  _R2_1_min = 0.12 * _Chain_d3_mm * (_z1 + 2) * IF(S_Units, 1, 1 / 25.4)
  _R2_1_max = 0.008 * _Chain_d3_mm * (_z1 ^ 2 + 180) * IF(S_Units, 1, 1 / 25.4)
  S2 = _z1
  _K3_prop = _Y
  AD2 = _xR2_2
  N2 = _xR1_1
  AC2 = _xdf2
  AA2 = _xda2
  X2 = _xalfa1
  AA135 = _v_max
  _v_var_min = _v * COS(PI() / _z1)
  _Safety_P = _sigma_tbl / _Sigma
  Q2 = _rx
  _Pitch_mm = _Pitch_i * 25.4
  _D1 = _Pitch / SIN(PI() / _z1)
  G2 = _Pitch
  _Chain_t = _Pitch
  _sigma_tbl = _PiMPa_cor * IF(S_Units, 1, 145.037)
  _Pp = _P1 * _K1 * _K2 * _K3 * _K4 * _K5 * _K6 * _K7
  _P2 = _P1 * _Efficiency / 100
  _i_req = _n1 / _n2_req
  N120 = _n1
  X154 = _Massm * 0.6723
  _Fr = _Fu + _Fc
  _Safety_S = _FB / _Fr
  _Safety_D = _FB / (_Fr * _K3)
  R2 = _f
  Y2 = _Dg1
  _Dg1 = _D1 - 2 * N211
  _da1_max = _D1 + 1.25 * _Pitch - _Chain_d3
  _da1_min = _D1 + 0.5 * _Chain_d3
  _L = _ChLinks * _Pitch
  B2 = _ChLinks
  H2 = _Chain_g
  X190 = _Chain_d3_mm / 25.4
  X209 = _Chain_d3 * 0.15
  W209 = _Chain_d3 * 0.1
  D2 = _Chain_d3
  X189 = _Chain_d1_mm / 25.4
  C2 = _Chain_d1
  F2 = _Chain_b2
  E2 = _Chain_b1
  O2 = _bf
  _ba = (W209 + X209) / 2
  O186 = (_v_var_max - _v_var_min) / ((_v_var_max + _v_var_min) / 2) * 100
  _MaxRows = ROWS(INDIRECT(_ChainTblName))
  _df1 = ROUND(_D1 - _R1 * 2, _RA)
  _dp1 = ROUND(_D1, _RA + 1)
  W167 = IF(S_Units, _df1 / 1000, _df1 * 25.4 / 1000)
  X140 = IF(IF(S_Units, PI() * _D1 * _n1 / 60000, _D1 * _n1 / 3.82) < _v_max, 1, 0)
  W144 = _z1 * _i_req
  P157 = _L * _Massm * IF(S_Units, 0.001, 0.0254 / 0.45359237)
  P2 = _ba
  Z144 = INT(W144 + 0.5)
  X144 = INT(W144)
  Y144 = IF(INT(X144 / 2) <> X144 / 2, X144, X144 + 1)
  _z2 = IF(_TeethOdd_2=1, Y144, Z144)
  W150 = 2 * _C_req / _Pitch + (_z1 + _z2) / 2 + ((_z2 - _z1) / (2 * PI())) ^ 2 * _Pitch / _C_req
  _alfa2_max = 140 - 90 / _z2
  _alfa2_min = 120 - 90 / _z2
  _C = 1 / 4 * (_ChLinks - (_z2 + _z1) / 2 + (
              (_ChLinks - (_z2 + _z1) / 2) ^ 2 - (8 * (_z2 - _z1) ^ 2 / (4 * PI() ^ 2))) ^ 0.5) * _Pitch
  _R2_2_min = 0.12 * _Chain_d3_mm * (_z2 + 2) * IF(S_Units, 1, 1 / 25.4)
  N184 = 0.02 * _C
  _R2_2_max = 0.008 * _Chain_d3_mm * (_z2 ^ 2 + 180) * IF(S_Units, 1, 1 / 25.4)
  _i = _z2 / _z1
  Z2 = _z2
  _D2 = _Pitch / SIN(PI() / _z2)
  _n2 = _n1 / _i
  _Dg2 = _D2 - 2 * N211
  _da2_max = _D2 + 1.25 * _Pitch - _Chain_d3
  _da2_min = _D2 + 0.5 * _Chain_d3
  AB2 = _D2
  _C_Pitch = _C / _Pitch
  A2 = _C
  _df2 = ROUND(_D2 - _R1 * 2, _RA)
  _dp2 = ROUND(_D2, _RA + 1)
  X166 = ROUND((1.2 * 10000000 * IF(S_Units, _P2, _P2 * 0.7457) / _n2) ^ 0.333, 1) / 1000
  _SS_Z = MIN(_z1, _z2)
  _SS_RPM = MAX(_n1, _n2)
  Z150 = INT(W150 + 0.5)
  X150 = INT(W150 / 2 + 0.5)
  P122 = IF(S_Units, _P2 * 9550 / _n2, _P2 * 63000 / _n2)
  X167 = IF(S_Units, _df2 / 1000, _df2 * 25.4 / 1000)
  _i_1 = IF(_i < 1, 1 / _i, _i)
  Y143 = 32 - 2.5 * _i
  Y182 = 2.5 - (_SS_Z - 4) * ((2.5 - 0.62) / 44)
  Z182 = 12.5 - (_SS_Z - 4) * ((12.5 - 3) / 44)
  X182 = 1 - (_SS_Z - 4) * (0.72 / 44)
  Y150 = X150 * 2
  X168 = PulleyMass(X167, X166, W165, W165 / 4, _Density)
  _ChLinks_prop = IF(_LinksEven=1, Y150, Z150)
  _SumMass = (W168 + X168) * IF(S_Units, 1, 2.2406) + P157'''
